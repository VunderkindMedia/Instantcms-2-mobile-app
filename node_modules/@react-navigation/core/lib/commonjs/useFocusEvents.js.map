{"version":3,"sources":["useFocusEvents.tsx"],"names":["useFocusEvents","state","emitter","navigation","React","useContext","NavigationContext","lastFocusedKeyRef","useRef","currentFocusedKey","routes","index","key","useEffect","addListener","emit","type","target","lastFocusedKey","current","undefined","isFocused"],"mappings":"gQAAA,oDACA,8EAYe,QAASA,CAAAA,cAAT,MAAqD,IAA3BC,CAAAA,KAA2B,MAA3BA,KAA2B,CAApBC,OAAoB,MAApBA,OAAoB,CAClE,GAAMC,CAAAA,UAAU,CAAGC,KAAK,CAACC,UAAN,CAAiBC,0BAAjB,CAAnB,CACA,GAAMC,CAAAA,iBAAiB,CAAGH,KAAK,CAACI,MAAN,EAA1B,CAEA,GAAMC,CAAAA,iBAAiB,CAAGR,KAAK,CAACS,MAAN,CAAaT,KAAK,CAACU,KAAnB,EAA0BC,GAApD,CAIAR,KAAK,CAACS,SAAN,CACE,iBACEV,CAAAA,UADF,cACEA,UAAU,CAAEW,WAAZ,CAAwB,OAAxB,CAAiC,iBAC/BZ,CAAAA,OAAO,CAACa,IAAR,CAAa,CAAEC,IAAI,CAAE,OAAR,CAAiBC,MAAM,CAAER,iBAAzB,CAAb,CAD+B,EAAjC,CADF,EADF,CAKE,CAACA,iBAAD,CAAoBP,OAApB,CAA6BC,UAA7B,CALF,EAQAC,KAAK,CAACS,SAAN,CACE,iBACEV,CAAAA,UADF,cACEA,UAAU,CAAEW,WAAZ,CAAwB,MAAxB,CAAgC,iBAC9BZ,CAAAA,OAAO,CAACa,IAAR,CAAa,CAAEC,IAAI,CAAE,MAAR,CAAgBC,MAAM,CAAER,iBAAxB,CAAb,CAD8B,EAAhC,CADF,EADF,CAKE,CAACA,iBAAD,CAAoBP,OAApB,CAA6BC,UAA7B,CALF,EAQAC,KAAK,CAACS,SAAN,CAAgB,UAAM,CACpB,GAAMK,CAAAA,cAAc,CAAGX,iBAAiB,CAACY,OAAzC,CAEAZ,iBAAiB,CAACY,OAAlB,CAA4BV,iBAA5B,CAIA,GAAIS,cAAc,GAAKE,SAAnB,EAAgC,CAACjB,UAArC,CAAiD,CAC/CD,OAAO,CAACa,IAAR,CAAa,CAAEC,IAAI,CAAE,OAAR,CAAiBC,MAAM,CAAER,iBAAzB,CAAb,EACD,CAID,GACES,cAAc,GAAKT,iBAAnB,EACA,EAAEN,UAAU,CAAGA,UAAU,CAACkB,SAAX,EAAH,CAA4B,IAAxC,CAFF,CAGE,CACA,OACD,CAED,GAAIH,cAAc,GAAKE,SAAvB,CAAkC,CAEhC,OACD,CAEDlB,OAAO,CAACa,IAAR,CAAa,CACXC,IAAI,CAAE,OADK,CAEXC,MAAM,CAAER,iBAFG,CAAb,EAKAP,OAAO,CAACa,IAAR,CAAa,CACXC,IAAI,CAAE,MADK,CAEXC,MAAM,CAAEC,cAFG,CAAb,EAID,CAlCD,CAkCG,CAACT,iBAAD,CAAoBP,OAApB,CAA6BC,UAA7B,CAlCH,EAmCD","sourcesContent":["import * as React from 'react';\nimport NavigationContext from './NavigationContext';\nimport { NavigationEventEmitter } from './useEventEmitter';\nimport { NavigationState } from './types';\n\ntype Options = {\n  state: NavigationState;\n  emitter: NavigationEventEmitter;\n};\n\n/**\n * Hook to take care of emitting `focus` and `blur` events.\n */\nexport default function useFocusEvents({ state, emitter }: Options) {\n  const navigation = React.useContext(NavigationContext);\n  const lastFocusedKeyRef = React.useRef<string | undefined>();\n\n  const currentFocusedKey = state.routes[state.index].key;\n\n  // When the parent screen changes its focus state, we also need to change child's focus\n  // Coz the child screen can't be focused if the parent screen is out of focus\n  React.useEffect(\n    () =>\n      navigation?.addListener('focus', () =>\n        emitter.emit({ type: 'focus', target: currentFocusedKey })\n      ),\n    [currentFocusedKey, emitter, navigation]\n  );\n\n  React.useEffect(\n    () =>\n      navigation?.addListener('blur', () =>\n        emitter.emit({ type: 'blur', target: currentFocusedKey })\n      ),\n    [currentFocusedKey, emitter, navigation]\n  );\n\n  React.useEffect(() => {\n    const lastFocusedKey = lastFocusedKeyRef.current;\n\n    lastFocusedKeyRef.current = currentFocusedKey;\n\n    // We wouldn't have `lastFocusedKey` on initial mount\n    // Fire focus event for the current route on mount if there's no parent navigator\n    if (lastFocusedKey === undefined && !navigation) {\n      emitter.emit({ type: 'focus', target: currentFocusedKey });\n    }\n\n    // We should only dispatch events when the focused key changed and navigator is focused\n    // When navigator is not focused, screens inside shouldn't receive focused status either\n    if (\n      lastFocusedKey === currentFocusedKey ||\n      !(navigation ? navigation.isFocused() : true)\n    ) {\n      return;\n    }\n\n    if (lastFocusedKey === undefined) {\n      // Only fire events after initial mount\n      return;\n    }\n\n    emitter.emit({\n      type: 'focus',\n      target: currentFocusedKey,\n    });\n\n    emitter.emit({\n      type: 'blur',\n      target: lastFocusedKey,\n    });\n  }, [currentFocusedKey, emitter, navigation]);\n}\n"]}