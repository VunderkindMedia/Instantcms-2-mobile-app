{"version":3,"sources":["getStateFromPath.tsx"],"names":["getStateFromPath","path","options","configs","concat","Object","keys","map","key","createNormalizedConfigs","result","current","remaining","replace","routeNames","params","config","match","paramPatterns","pattern","split","filter","p","startsWith","length","reduce","acc","i","value","parse","undefined","segments","decodeURIComponent","shift","join","state","routes","name","helper","routeName","push","query","route","queryString","parseFunction","findParseConfigForRoute","forEach","routeConfig","createConfigItem","nestedKey","pop","RegExp"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport { NavigationState, PartialState, InitialState } from './types';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]: string | { path: string; parse?: ParseConfig } | Options;\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map(key => createNormalizedConfigs(key, options))\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames;\n    let params;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = config.routeNames;\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter(p => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n\n    if (routeNames.length === 1) {\n      state = {\n        routes: [\n          { name: routeNames.shift() as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      state = {\n        routes: [{ name: routeNames.shift() as string, state: { routes: [] } }],\n      };\n\n      let helper = state.routes[0].state as InitialState;\n      let routeName;\n\n      while ((routeName = routeNames.shift())) {\n        if (routeNames.length === 0) {\n          helper.routes.push({\n            name: routeName,\n            ...(params && { params }),\n          });\n        } else {\n          helper.routes[0] = {\n            name: routeName,\n            state: {\n              routes: [],\n            },\n          };\n          helper = helper.routes[0].state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current.routes[0].state) {\n        current = current.routes[0].state;\n      }\n\n      current.routes[0].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current.routes[0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[0].state;\n    }\n\n    const route = current.routes[0];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, options);\n\n    if (parseFunction) {\n      Object.keys(params).forEach(name => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = []\n): RouteConfig[] {\n  const configs = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    configs.push(createConfigItem(routeNames, value));\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it could have config object and optionally nested config\n    Object.keys(value).forEach(nestedKey => {\n      if (nestedKey === 'path') {\n        configs.push(\n          createConfigItem(\n            routeNames,\n            value[nestedKey] as string,\n            value.parse ? (value.parse as ParseConfig) : undefined\n          )\n        );\n      } else if (nestedKey === 'parse') {\n        // We handle custom parse function when a `path` is specified (in nestedKey === path)\n      } else {\n        // If the name of the key is not `path` or `parse`, it's a nested config for route\n        // So we need to traverse into it and collect the configs\n        const result = createNormalizedConfigs(\n          nestedKey,\n          routeConfig[key] as Options,\n          routeNames\n        );\n\n        configs.push(...result);\n      }\n    });\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  config: Options\n): ParseConfig | undefined {\n  if (config[routeName]) {\n    return (config[routeName] as { parse?: ParseConfig }).parse;\n  }\n\n  for (const name in config) {\n    if (typeof config[name] === 'object') {\n      const parse = findParseConfigForRoute(routeName, config[name] as Options);\n\n      if (parse) {\n        return parse;\n      }\n    }\n  }\n\n  return undefined;\n}\n"]}