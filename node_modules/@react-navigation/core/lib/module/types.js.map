{"version":3,"sources":["types.tsx"],"names":["PrivateValueStore"],"mappings":"mEAySA,UAAaA,CAAAA,iBAAb","sourcesContent":["import * as CommonActions from './CommonActions';\nimport * as React from 'react';\n\nexport type CommonAction = CommonActions.Action;\n\nexport type NavigationState = {\n  /**\n   * Unique key for the navigation state.\n   */\n  key: string;\n  /**\n   * Index of the currently focused route.\n   */\n  index: number;\n  /**\n   * List of valid route names as defined in the screen components.\n   */\n  routeNames: string[];\n  /**\n   * List of rendered routes.\n   */\n  routes: (Route<string> & {\n    state?: NavigationState | PartialState<NavigationState>;\n  })[];\n  /**\n   * Custom type for the state, whether it's for tab, stack, drawer etc.\n   * During rehydration, the state will be discarded if type doesn't match with router type.\n   * It can also be used to detect the type of the navigator we're dealing with.\n   */\n  type: string;\n  /**\n   * Whether the navigation state has been rehydrated.\n   */\n  stale: false;\n};\n\nexport type InitialState = Partial<\n  Omit<NavigationState, 'stale' | 'routes'>\n> & {\n  routes: (Omit<Route<string>, 'key'> & { state?: InitialState })[];\n};\n\nexport type PartialState<State extends NavigationState> = Partial<\n  Omit<State, 'stale' | 'type' | 'key' | 'routes' | 'routeNames'>\n> & {\n  stale?: true;\n  type?: string;\n  routes: (Omit<Route<string>, 'key'> & {\n    key?: string;\n    state?: InitialState;\n  })[];\n};\n\nexport type Route<RouteName extends string> = {\n  /**\n   * Unique key for the route.\n   */\n  key: string;\n  /**\n   * User-provided name for the route.\n   */\n  name: RouteName;\n  /**\n   * Params for the route.\n   */\n  params?: object;\n};\n\nexport type NavigationAction = {\n  /**\n   * Type of the action (e.g. `NAVIGATE`)\n   */\n  type: string;\n  /**\n   * Additional data for the action\n   */\n  payload?: object;\n  /**\n   * Key of the route which dispatched this action.\n   */\n  source?: string;\n  /**\n   * Key of the navigator which should handle this action.\n   */\n  target?: string;\n};\n\nexport type ActionCreators<Action extends NavigationAction> = {\n  [key: string]: (...args: any) => Action;\n};\n\nexport type DefaultRouterOptions = {\n  /**\n   * Name of the route to focus by on initial render.\n   * If not specified, usually the first route is used.\n   */\n  initialRouteName?: string;\n};\n\nexport type DefaultNavigatorOptions<\n  ScreenOptions extends object\n> = DefaultRouterOptions & {\n  /**\n   * Children React Elements to extract the route configuration from.\n   * Only `Screen` components are supported as children.\n   */\n  children: React.ReactNode;\n  /**\n   * Default options for all screens under this navigator.\n   */\n  screenOptions?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamListBase, string>;\n        navigation: any;\n      }) => ScreenOptions);\n};\n\nexport type RouterFactory<\n  State extends NavigationState,\n  Action extends NavigationAction,\n  RouterOptions extends DefaultRouterOptions\n> = (options: RouterOptions) => Router<State, Action>;\n\nexport type RouterConfigOptions = {\n  routeNames: string[];\n  routeParamList: ParamListBase;\n};\n\nexport type Router<\n  State extends NavigationState,\n  Action extends NavigationAction\n> = {\n  /**\n   * Type of the router. Should match the `type` property in state.\n   * If the type doesn't match, the state will be discarded during rehydration.\n   */\n  type: State['type'];\n\n  /**\n   * Initialize the navigation state.\n   *\n   * @param options.routeNames List of valid route names as defined in the screen components.\n   * @param options.routeParamsList Object containing params for each route.\n   */\n  getInitialState(options: RouterConfigOptions): State;\n\n  /**\n   * Rehydrate the full navigation state from a given partial state.\n   *\n   * @param partialState Navigation state to rehydrate from.\n   * @param options.routeNames List of valid route names as defined in the screen components.\n   * @param options.routeParamsList Object containing params for each route.\n   */\n  getRehydratedState(\n    partialState: PartialState<State> | State,\n    options: RouterConfigOptions\n  ): State;\n\n  /**\n   * Take the current state and updated list of route names, and return a new state.\n   *\n   * @param state State object to update.\n   * @param options.routeNames New list of route names.\n   * @param options.routeParamsList Object containing params for each route.\n   */\n  getStateForRouteNamesChange(\n    state: State,\n    options: RouterConfigOptions\n  ): State;\n\n  /**\n   * Take the current state and key of a route, and return a new state with the route focused\n   *\n   * @param state State object to apply the action on.\n   * @param key Key of the route to focus.\n   */\n  getStateForRouteFocus(state: State, key: string): State;\n\n  /**\n   * Take the current state and action, and return a new state.\n   * If the action cannot be handled, return `null`.\n   *\n   * @param state State object to apply the action on.\n   * @param action Action object to apply.\n   * @param options.routeNames List of valid route names as defined in the screen components.\n   * @param options.routeParamsList Object containing params for each route.\n   */\n  getStateForAction(\n    state: State,\n    action: Action,\n    options: RouterConfigOptions\n  ): State | PartialState<State> | null;\n\n  /**\n   * Whether the action should also change focus in parent navigator\n   *\n   * @param action Action object to check.\n   */\n  shouldActionChangeFocus(action: NavigationAction): boolean;\n\n  /**\n   * Action creators for the router.\n   */\n  actionCreators?: ActionCreators<Action>;\n};\n\nexport type ParamListBase = Record<string, object | undefined>;\n\nexport type EventMapBase = Record<\n  string,\n  { data?: any; canPreventDefault?: boolean }\n>;\n\nexport type EventMapCore = {\n  focus: { data: undefined };\n  blur: { data: undefined };\n  state: { data: { state: NavigationState } };\n};\n\nexport type EventArg<\n  EventName extends string,\n  CanPreventDefault extends boolean | undefined = false,\n  Data = undefined\n> = {\n  /**\n   * Type of the event (e.g. `focus`, `blur`)\n   */\n  readonly type: EventName;\n} & (CanPreventDefault extends true\n  ? {\n      /**\n       * Whether `event.preventDefault()` was called on this event object.\n       */\n      readonly defaultPrevented: boolean;\n      /**\n       * Prevent the default action which happens on this event.\n       */\n      preventDefault(): void;\n    }\n  : {}) &\n  (Data extends undefined ? {} : { readonly data: Data });\n\nexport type EventListenerCallback<\n  EventMap extends EventMapBase,\n  EventName extends keyof EventMap\n> = (\n  e: EventArg<\n    Extract<EventName, string>,\n    EventMap[EventName]['canPreventDefault'],\n    EventMap[EventName]['data']\n  >\n) => void;\n\nexport type EventConsumer<EventMap extends EventMapBase> = {\n  /**\n   * Subscribe to events from the parent navigator.\n   *\n   * @param type Type of the event (e.g. `focus`, `blur`)\n   * @param callback Callback listener which is executed upon receiving the event.\n   */\n  addListener<EventName extends Extract<keyof EventMap, string>>(\n    type: EventName,\n    callback: EventListenerCallback<EventMap, EventName>\n  ): () => void;\n  removeListener<EventName extends Extract<keyof EventMap, string>>(\n    type: EventName,\n    callback: EventListenerCallback<EventMap, EventName>\n  ): void;\n};\n\nexport type EventEmitter<EventMap extends EventMapBase> = {\n  /**\n   * Emit an event to child screens.\n   *\n   * @param options.type Type of the event (e.g. `focus`, `blur`)\n   * @param [options.data] Optional information regarding the event.\n   * @param [options.target] Key of the target route which should receive the event.\n   * If not specified, all routes receive the event.\n   */\n  emit<EventName extends Extract<keyof EventMap, string>>(\n    options: {\n      type: EventName;\n      target?: string;\n    } & (EventMap[EventName]['canPreventDefault'] extends true\n      ? { canPreventDefault: true }\n      : {}) &\n      (EventMap[EventName]['data'] extends undefined\n        ? {}\n        : { data: EventMap[EventName]['data'] })\n  ): EventArg<\n    EventName,\n    EventMap[EventName]['canPreventDefault'],\n    EventMap[EventName]['data']\n  >;\n};\n\nexport class PrivateValueStore<A, B, C> {\n  /**\n   * UGLY HACK! DO NOT USE THE TYPE!!!\n   *\n   * TypeScript requires a type to be used to be able to infer it.\n   * The type should exist as its own without any operations such as union.\n   * So we need to figure out a way to store this type in a property.\n   * The problem with a normal property is that it shows up in intelliSense.\n   * Adding private keyword works, but the annotation is stripped away in declaration.\n   * Turns out if we use an empty string, it doesn't show up in intelliSense.\n   */\n  protected ''?: { a: A; b: B; c: C };\n}\n\ntype NavigationHelpersCommon<\n  ParamList extends ParamListBase,\n  State extends NavigationState = NavigationState\n> = {\n  /**\n   * Dispatch an action or an update function to the router.\n   * The update function will receive the current state,\n   *\n   * @param action Action object or update function.\n   */\n  dispatch(\n    action: NavigationAction | ((state: State) => NavigationAction)\n  ): void;\n\n  /**\n   * Navigate to a route in current navigation tree.\n   *\n   * @param name Name of the route to navigate to.\n   * @param [params] Params object for the route.\n   */\n  navigate<RouteName extends keyof ParamList>(\n    ...args: ParamList[RouteName] extends undefined | any\n      ? [RouteName] | [RouteName, ParamList[RouteName]]\n      : [RouteName, ParamList[RouteName]]\n  ): void;\n\n  /**\n   * Navigate to a route in current navigation tree.\n   *\n   * @param route Object with `key` or `name` for the route to navigate to, and a `params` object.\n   */\n  navigate<RouteName extends keyof ParamList>(\n    route:\n      | { key: string; params?: ParamList[RouteName] }\n      | { name: RouteName; key?: string; params: ParamList[RouteName] }\n  ): void;\n\n  /**\n   * Replace the current route with a new one.\n   *\n   * @param name Route name of the new route.\n   * @param [params] Params object for the new route.\n   */\n  replace<RouteName extends keyof ParamList>(\n    ...args: ParamList[RouteName] extends undefined\n      ? [RouteName] | [RouteName, ParamList[RouteName]]\n      : [RouteName, ParamList[RouteName]]\n  ): void;\n\n  /**\n   * Reset the navigation state to the provided state.\n   *\n   * @param state Navigation state object.\n   */\n  reset(state: PartialState<State> | State): void;\n\n  /**\n   * Reset the navigation state of the root navigator to the provided state.\n   *\n   * @param state Navigation state object.\n   */\n  resetRoot(state?: PartialState<NavigationState> | NavigationState): void;\n\n  /**\n   * Go back to the previous route in history.\n   */\n  goBack(): void;\n\n  /**\n   * Check if the screen is focused. The method returns `true` if focused, `false` otherwise.\n   * Note that this method doesn't re-render screen when the focus changes. So don't use it in `render`.\n   * To get notified of focus changes, use `addListener('focus', cb)` and `addListener('blur', cb)`.\n   * To conditionally render content based on focus state, use the `useIsFocused` hook.\n   */\n  isFocused(): boolean;\n\n  /**\n   * Check if dispatching back action will be handled by navigation.\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\n   */\n  canGoBack(): boolean;\n} & PrivateValueStore<ParamList, keyof ParamList, {}>;\n\nexport type NavigationHelpers<\n  ParamList extends ParamListBase,\n  EventMap extends EventMapBase = {}\n> = NavigationHelpersCommon<ParamList> &\n  EventEmitter<EventMap> & {\n    /**\n     * Update the param object for the route.\n     * The new params will be shallow merged with the old one.\n     *\n     * @param params Params object for the current route.\n     */\n    setParams<RouteName extends keyof ParamList>(\n      params: Partial<ParamList[RouteName]>\n    ): void;\n  };\n\nexport type NavigationContainerProps = {\n  /**\n   * Initial navigation state for the child navigators.\n   */\n  initialState?: InitialState;\n  /**\n   * Callback which is called with the latest navigation state when it changes.\n   */\n  onStateChange?: (state: NavigationState | undefined) => void;\n  /**\n   * Whether this navigation container should be independent of parent containers.\n   * If this is not set to `true`, this container cannot be nested inside another container.\n   * Setting it to `true` disconnects any children navigators from parent container.\n   */\n  independent?: boolean;\n  /**\n   * Children elements to render.\n   */\n  children: React.ReactNode;\n};\n\nexport type NavigationProp<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = string,\n  State extends NavigationState = NavigationState,\n  ScreenOptions extends object = {},\n  EventMap extends EventMapBase = {}\n> = NavigationHelpersCommon<ParamList, State> & {\n  /**\n   * Update the param object for the route.\n   * The new params will be shallow merged with the old one.\n   *\n   * @param params Params object for the current route.\n   */\n  setParams(params: Partial<ParamList[RouteName]>): void;\n\n  /**\n   * Update the options for the route.\n   * The options object will be shallow merged with default options object.\n   *\n   * @param options Options object for the route.\n   */\n  setOptions(options: Partial<ScreenOptions>): void;\n\n  /**\n   * Returns the parent navigator, if any. Reason why the function is called\n   * dangerouslyGetParent is to warn developers against overusing it to eg. get parent\n   * of parent and other hard-to-follow patterns.\n   */\n  dangerouslyGetParent<T = NavigationProp<ParamListBase> | undefined>(): T;\n\n  /**\n   * Returns the navigator's state. Reason why the function is called\n   * dangerouslyGetState is to discourage developers to use internal navigation's state.\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\n   */\n  dangerouslyGetState(): State;\n} & EventConsumer<EventMap & EventMapCore> &\n  PrivateValueStore<ParamList, RouteName, EventMap>;\n\nexport type RouteProp<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList\n> = Omit<Route<Extract<RouteName, string>>, 'params'> &\n  (ParamList[RouteName] extends undefined\n    ? {}\n    : {\n        /**\n         * Params for this route\n         */\n        params: ParamList[RouteName];\n      });\n\nexport type CompositeNavigationProp<\n  A extends NavigationProp<ParamListBase, string, any, any>,\n  B extends NavigationHelpersCommon<ParamListBase, any>\n> = Omit<A & B, keyof NavigationProp<any>> &\n  NavigationProp<\n    /**\n     * Param list from both navigation objects needs to be combined\n     * For example, we should be able to navigate to screens in both A and B\n     */\n    (A extends NavigationHelpersCommon<infer T> ? T : never) &\n      (B extends NavigationHelpersCommon<infer U> ? U : never),\n    /**\n     * The route name should refer to the route name specified in the first type\n     * Ideally it should work for any of them, but it's not possible to infer that way\n     */\n    A extends NavigationProp<any, infer R> ? R : string,\n    /**\n     * The type of state should refer to the state specified in the first type\n     */\n    A extends NavigationProp<any, any, infer S> ? S : NavigationState,\n    /**\n     * Screen options from both navigation objects needs to be combined\n     * This allows typechecking `setOptions`\n     */\n    (A extends NavigationProp<any, any, any, infer O> ? O : {}) &\n      (B extends NavigationProp<any, any, any, infer P> ? P : {}),\n    /**\n     * Event consumer config should refer to the config specified in the first type\n     * This allows typechecking `addListener`/`removeListener`\n     */\n    A extends NavigationProp<any, any, any, any, infer E> ? E : {}\n  >;\n\nexport type Descriptor<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = string,\n  State extends NavigationState = NavigationState,\n  ScreenOptions extends object = {},\n  EventMap extends EventMapBase = {}\n> = {\n  /**\n   * Render the component associated with this route.\n   */\n  render(): JSX.Element;\n\n  /**\n   * Options for the route.\n   */\n  options: ScreenOptions;\n\n  /**\n   * Navigation object for the screen\n   */\n  navigation: NavigationProp<\n    ParamList,\n    RouteName,\n    State,\n    ScreenOptions,\n    EventMap\n  >;\n};\n\nexport type RouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  ScreenOptions extends object\n> = {\n  /**\n   * Route name of this screen.\n   */\n  name: RouteName;\n\n  /**\n   * Navigator options for this screen.\n   */\n  options?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamList, RouteName>;\n        navigation: any;\n      }) => ScreenOptions);\n\n  /**\n   * Initial params object for the route.\n   */\n  initialParams?: Partial<ParamList[RouteName]>;\n} & (\n  | {\n      /**\n       * React component to render for this screen.\n       */\n      component: React.ComponentType<any>;\n    }\n  | {\n      /**\n       * Render callback to render content of this screen.\n       */\n      children: (props: {\n        route: RouteProp<ParamList, RouteName>;\n        navigation: any;\n      }) => React.ReactNode;\n    }\n);\n\nexport type NavigationContainerRef =\n  | (NavigationHelpers<ParamListBase> & {\n      /**\n       * Reset the navigation state of the root navigator to the provided state.\n       *\n       * @param state Navigation state object.\n       */\n      resetRoot(state?: PartialState<NavigationState> | NavigationState): void;\n      getRootState(): NavigationState;\n    })\n  | undefined\n  | null;\n\nexport type TypedNavigator<\n  ParamList extends ParamListBase,\n  ScreenOptions extends object,\n  Navigator extends React.ComponentType<any>\n> = {\n  /**\n   * Navigator component which manages the child screens.\n   */\n  Navigator: React.ComponentType<\n    Omit<\n      React.ComponentProps<Navigator>,\n      'initialRouteName' | 'screenOptions'\n    > & {\n      /**\n       * Name of the route to focus by on initial render.\n       * If not specified, usually the first route is used.\n       */\n      initialRouteName?: keyof ParamList;\n      /**\n       * Default options for all screens under this navigator.\n       */\n      screenOptions?:\n        | ScreenOptions\n        | ((props: {\n            route: RouteProp<ParamList, keyof ParamList>;\n            navigation: any;\n          }) => ScreenOptions);\n    }\n  >;\n  /**\n   * Component used for specifying route configuration.\n   */\n  Screen: <RouteName extends keyof ParamList>(\n    _: RouteConfig<ParamList, RouteName, ScreenOptions>\n  ) => null;\n};\n"]}